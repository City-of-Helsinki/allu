package fi.hel.allu.model.deployment.paymentclass;

import com.querydsl.sql.Configuration;
import com.querydsl.sql.SQLQueryFactory;
import com.querydsl.sql.SQLTemplates;
import com.querydsl.sql.spatial.PostGISTemplates;

import fi.hel.allu.common.wfs.WfsUtil;
import fi.hel.allu.model.deployment.helsinkixml.HelsinkiGeom.GmlBoundary;

import org.geolatte.geom.Polygon;
import org.geolatte.geom.builder.DSL;
import org.geolatte.geom.builder.DSL.LinearRing2DToken;

import javax.sql.DataSource;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import static fi.hel.allu.QPaymentClass.paymentClass1;

/**
 * Converts WFS city district data to SQL, which can be used to insert the data
 * to database. To get the input XML file, download it from here:
 * http://kartta.hel.fi/ws/geoserver/helsinki/wfs?SERVICE=WFS&VERSION=1.0.0&REQUEST=GetFeature&TYPENAME=helsinki:Allu_maksuvyohykkeet_testi&SRSNAME=EPSG:3879
 */
public class PaymentClassReader {

  private static final String USAGE = "Required arguments missing.\n"
      + "Specify one input xml file and the name of output sql file!";

  private static final String SQL_COMMENTS =
      "-- DO NOT EDIT THIS FILE MANUALLY!\n\n"
      + "-- This file was autogenerated. The command used was:\n"
      + "-- %s\n\n"
      + "-- See the documentation for more info.\n\n";

  private static SQLQueryFactory queryFactory;

  public static void main(String[] argv) throws IOException {
    if (argv.length < 2) {
      System.out.println(USAGE);
      return;
    } else {
      SQLTemplates templates = PostGISTemplates.builder().printSchema().build();
      Configuration configuration = new Configuration(templates);
      configuration.setUseLiterals(true);

      queryFactory = new SQLQueryFactory(configuration, (DataSource) null);
      List<String> sqlInserts = createSqlInserts(readPaymentClasses(argv[0]));

      try (OutputStream output = Files.newOutputStream(Paths.get(argv[1]))) {
        output.write(String.format(SQL_COMMENTS, getCmdline()).getBytes());
        for (String insert : sqlInserts) {
          output.write((insert + ";\n").getBytes());
        }
      }
    }
  }

  static PaymentClassXml readPaymentClasses(String path) throws IOException {
    byte[] encoded = Files.readAllBytes(Paths.get(path));
    String wfsXml = new String(encoded, "UTF-8");
    return WfsUtil.unmarshalWfs(wfsXml, PaymentClassXml.class);
  }

  private static List<String> createSqlInserts(PaymentClassXml paymentClassXml) throws IOException {
    List<PaymentClassXml.FeatureMember> featureMembers = paymentClassXml.featureMember;
     Collections.sort(featureMembers, (left, right) -> left.paymentClass.id - right.paymentClass.id);
     List<String> sqlInserts = featureMembers.stream().map(fm -> createSql(fm.paymentClass))
         .collect(Collectors.toList());
     return sqlInserts;
  }

  private static String createSql(PaymentClassXml.HelsinkiAlluMaksuvyohyke xmlPaymentClass) {
    // The polygon's outer ring (exterior) + possible inner rings (holes):
    List<LinearRing2DToken> rings = new ArrayList<>();
    rings.add(toRing(xmlPaymentClass.geometry.polygon.outerBoundary));
    if (xmlPaymentClass.geometry.polygon.innerBoundary != null) {
      rings.addAll(
          xmlPaymentClass.geometry.polygon.innerBoundary.stream().map(b -> toRing(b)).collect(Collectors.toList()));
    }
    Polygon polygon = DSL.polygon(3879, rings.toArray(new LinearRing2DToken[0]));

    String insert = queryFactory.insert(paymentClass1).set(paymentClass1.geometry, polygon)
        .set(paymentClass1.paymentClass, PaymentClass.valueOf(xmlPaymentClass.paymentClass).getValue())
        .getSQL().get(0).getSQL();
    return insert;
  }

  private static LinearRing2DToken toRing(GmlBoundary boundary) {
    List<DSL.Vertex2DToken> vertex2DTokens =  Arrays.stream(boundary.linearRing.coordinates.split(" "))
    .map(c -> c.split(","))
    .map(xy -> DSL.c(Double.parseDouble(xy[0]), Double.parseDouble(xy[1])))
    .collect(Collectors.toList());
    return DSL.ring(vertex2DTokens.toArray(new DSL.Vertex2DToken[vertex2DTokens.size()]));
  }

  // Find out the java command line that was used
  private static String getCmdline() {
    RuntimeMXBean bean = ManagementFactory.getRuntimeMXBean();
    StringBuilder cmdLine = new StringBuilder("java");
    for (String arg : bean.getInputArguments()) {
      cmdLine.append(" " + arg);
    }
    cmdLine.append(" -classpath " + System.getProperty("java.class.path"));
    cmdLine.append(" " + System.getProperty("sun.java.command"));
    return cmdLine.toString();
  }

  // Map payment class names to values:
  enum PaymentClass {
    ML1(1), ML2(2), ML3(3);

    final private int value;

    private PaymentClass(int value) {
      this.value = value;
    }

    int getValue() {
      return value;
    }
  }
}

