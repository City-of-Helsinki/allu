package fi.hel.allu.model.deployment;

import com.querydsl.core.types.Expression;
import com.querydsl.core.types.dsl.BooleanExpression;
import com.querydsl.core.types.dsl.Expressions;
import com.querydsl.sql.Configuration;
import com.querydsl.sql.SQLQueryFactory;
import com.querydsl.sql.SQLTemplates;
import com.querydsl.sql.spatial.PostGISTemplates;

import org.geolatte.common.Feature;
import org.geolatte.common.FeatureCollection;
import org.geolatte.common.dataformats.json.jackson.JsonException;
import org.geolatte.common.dataformats.json.jackson.JsonMapper;
import org.geolatte.geom.Geometry;
import org.geolatte.geom.crs.CrsId;

import javax.sql.DataSource;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;

import static fi.hel.allu.QFixedLocation.fixedLocation;

/**
 * Utility class to generate SQL commands for inserting geometries into
 * allu.fixed_location. This class is not used by the model-service application
 * but it's needed when new geometries are received.
 * <p>
 * To run, set class as applications main class and provide two parameters:
 * input file name and output file name.
 * <p>
 * The input is a GeoJSON file containing one FeatureCollection. The
 * FeatureCollection is assumed to have CRSID 3879 (i.e., if it has something
 * else, that value is silently ignored). Every feature needs to have the
 * following properties:
 *
 * <ul>
 * <li>Paikka: must match a FixedLocation's area name
 * <li>Lohko: must match a FixedLocation's section name. This is optional; if
 * absent, there must be a FixedLocation with NULL section in the database.
 * </ul>
 * <p>
 * The output will be a SQL command script that inserts the geometries into
 * database.
 */
public class LocationGeometryReader {

  private SQLQueryFactory queryFactory;

  private static final String USAGE = "Required arguments missing.\n"
      + "Specify all input files and the name of output file!";

  private static final String SQL_COMMENTS =
      "-- DO NOT EDIT THIS FILE MANUALLY!\n\n"
      + "-- This file was autogenerated. The command used was:\n"
      + "-- %s\n\n"
      + "-- See the documentation for more info.\n\n";

  private static final String SQL_PREAMBLE =
      "CREATE FUNCTION check_allu_name(areaname TEXT, sectionname TEXT)\n"
      + "RETURNS VOID AS $$\n"
      + "DECLARE\n"
      + "   match_count INT;\n"
      + "BEGIN\n"
      + "   IF sectionname IS NULL OR sectionname = '' THEN\n"
      + "       SELECT COUNT(*) INTO STRICT match_count FROM\n"
      + "           (SELECT DISTINCT area, section from allu.fixed_location) AS l WHERE\n"
      + "           l.area LIKE check_allu_name.areaname AND l.section IS NULL;\n"
      + "   ELSE\n"
      + "       SELECT COUNT(*) INTO STRICT match_count FROM\n"
      + "           (SELECT DISTINCT area, section from allu.fixed_location) AS l WHERE\n"
      + "           l.area LIKE check_allu_name.areaname AND l.section = sectionname;\n"
      + "   END IF;\n"
      + "   IF match_count <> 1 THEN\n"
      + "       RAISE EXCEPTION 'Name % matches % areas in database', check_allu_name.areaname, match_count;\n"
      + "   END IF;\n"
      + "END;\n"
      + "$$ LANGUAGE plpgsql;\n";

  private static final String SQL_EPILOGUE = "DROP FUNCTION check_allu_name(TEXT, TEXT);\n";

  public LocationGeometryReader() {
    SQLTemplates templates = PostGISTemplates.builder().printSchema().build();
    Configuration configuration = new Configuration(templates);
    configuration.setUseLiterals(true);
    // Not really querying anything, so null datasource is OK:
    DataSource dataSource = null;
    queryFactory = new SQLQueryFactory(configuration, dataSource);
  }

  public static void main(String[] args) throws IOException, JsonException {
    if (args.length < 2) {
      System.out.println(USAGE);
      return;
    } else {
      String[] inputFiles = Arrays.copyOf(args, args.length - 1);
      if (!checkInputFiles(inputFiles)) {
        return;
      }
      OutputStream output = Files.newOutputStream(Paths.get(args[args.length - 1]));
      output.write(String.format(SQL_COMMENTS, getCmdline()).getBytes());
      output.write(SQL_PREAMBLE.getBytes());
      LocationGeometryReader lgr = new LocationGeometryReader();
      for (String fileName : inputFiles) {
        output.write(String.format("-- input file: %s\n", fileName).getBytes());
        String content = new String(Files.readAllBytes(Paths.get(fileName)), "UTF-8");
        FeatureCollection fc = lgr.parseJson(content);
        for (Feature f : fc.getFeatures()) {
          lgr.insertIntoDb(f, output);
        }
      }
      output.write(SQL_EPILOGUE.getBytes());
    }
  }

  private static boolean checkInputFiles(String fileNames[]) {
    boolean allOk = true;
    for (String fileName : fileNames) {
      if (!Files.isReadable(Paths.get(fileName))) {
        System.err.println("Input file " + fileName + "is not readable.");
        allOk = false;
      }
    }
    return allOk;
  }

  // Find out the java command line that was used
  private static String getCmdline() {
    RuntimeMXBean bean = ManagementFactory.getRuntimeMXBean();
    StringBuilder cmdLine = new StringBuilder("java");
    for (String arg : bean.getInputArguments()) {
      cmdLine.append(" " + arg);
    }
    cmdLine.append(" -classpath " + System.getProperty("java.class.path"));
    cmdLine.append(" " + System.getProperty("sun.java.command"));
    return cmdLine.toString();
  }

  // Parse the input file
  private FeatureCollection parseJson(String jsonContents) throws JsonException
  {
    JsonMapper mapper = new JsonMapper(CrsId.valueOf(3879), true, false);
    return mapper.fromJson(jsonContents, FeatureCollection.class);
  }

  // Generate SQL to insert geometries into database:
  private void insertIntoDb(Feature feature, OutputStream output) throws IOException {
    Geometry geometry = feature.getGeometry();

    String area = (String) feature.getProperty("Paikka");
    String section = (String) feature.getProperty("Lohko");
    if (area == null) {
      // No area given; this can be a bridge banner listing
      Integer bridge = (Integer) feature.getProperty("Silta");
      String side = (String) feature.getProperty("Sivu");
      if (bridge != null && side != null) {
        area = String.format("%d%s ", bridge, side);
      }
    }
    area += "%"; // To match the beginning
    BooleanExpression sectionCondition;
    if (section == null) {
      sectionCondition = fixedLocation.section.isNull();
    } else {
      sectionCondition = fixedLocation.section.eq(section);
    }

    Expression<?> checkExpr = Expressions.simpleTemplate(String.class, "check_allu_name({0},{1})",
        Expressions.constant(area),
        section == null ? Expressions.nullExpression() : Expressions.constant(section));
    String check = queryFactory.select(checkExpr).getSQL().getSQL();
    output.write((check + ";\n").getBytes());
    String insert = queryFactory.update(fixedLocation).set(fixedLocation.geometry, geometry)
        .where(fixedLocation.area.like(area).and(sectionCondition)).getSQL().get(0).getSQL();
    output.write((insert + ";\n").getBytes());
  }
}
