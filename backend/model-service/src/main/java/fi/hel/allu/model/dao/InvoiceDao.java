package fi.hel.allu.model.dao;

import com.querydsl.core.Tuple;
import com.querydsl.core.types.QBean;
import com.querydsl.sql.SQLQueryFactory;
import com.querydsl.sql.dml.SQLInsertClause;
import com.querydsl.sql.dml.SQLUpdateClause;
import fi.hel.allu.QApplication;
import fi.hel.allu.common.domain.types.StatusType;
import fi.hel.allu.common.exception.NoSuchEntityException;
import fi.hel.allu.common.util.EmptyUtil;
import fi.hel.allu.model.domain.Invoice;
import fi.hel.allu.model.domain.InvoiceRow;
import fi.hel.allu.model.querydsl.ExcludingMapper;
import fi.hel.allu.model.querydsl.ExcludingMapper.NullHandling;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.time.ZonedDateTime;
import java.util.*;
import java.util.stream.Collectors;

import static com.querydsl.core.group.GroupBy.groupBy;
import static com.querydsl.core.group.GroupBy.list;
import static com.querydsl.core.types.Projections.bean;
import static fi.hel.allu.QApplication.application;
import static fi.hel.allu.QInvoice.invoice;
import static fi.hel.allu.QInvoiceRow.invoiceRow;

/**
 * The DAO class for invoice access
 */
@Repository
public class InvoiceDao {
  private final SQLQueryFactory queryFactory;

  // While inserting, don't copy id or applicationId from the object:
  private static final ExcludingMapper EXCLUDE_IDS = new ExcludingMapper(NullHandling.DEFAULT,
      Arrays.asList(invoice.id, invoice.applicationId));

  private static final ExcludingMapper EXCLUDE_ROW_IDS = new ExcludingMapper(NullHandling.DEFAULT,
      Arrays.asList(invoiceRow.id, invoiceRow.invoiceId));
  private final QBean<Invoice> invoiceBean = bean(Invoice.class, invoice.all());
  private final QBean<InvoiceRow> invoiceRowBean = bean(InvoiceRow.class, invoiceRow.all());

  @Autowired
  public InvoiceDao(SQLQueryFactory queryFactory) {
    this.queryFactory = queryFactory;
  }

  /**
   * Insert a new invoice for application. All data except id and applicationId
   * will be copied from the new invoice into database (id will be generated by
   * database and applicationId is set from the parameter applicationId.
   *
   * @param applicationId The application's ID
   * @param newInvoice Contents of the new invoice
   * @return the database id of inserted invoice
   */
  @Transactional
  public int insert(int applicationId, Invoice newInvoice) {
    int invoiceId = queryFactory.insert(invoice)
        .populate(newInvoice, EXCLUDE_IDS)
        .set(invoice.applicationId, applicationId)
        .executeWithKey(invoice.id);
    insertRows(invoiceId, newInvoice.getRows());
    return invoiceId;
  }

  /**
   * Find invoices by their database IDs
   *
   * @param invoiceIds The database IDs of the invoice
   * @return The found {@link Invoice}s or empty list
   */
  @Transactional(readOnly = true)
  public List<Invoice> findInvoices(List<Integer> invoiceIds) {
    Map<Integer, Invoice> mappedResult = new HashMap<>();
    if (EmptyUtil.isNotEmpty(invoiceIds)) {
      List<Tuple> invoiceTuples = queryFactory.select(invoiceBean, invoiceRowBean).from(invoice).leftJoin(invoiceRow)
              .on(invoice.id.eq(invoiceRow.invoiceId)).where(invoice.id.in(invoiceIds))
              .orderBy(invoiceRow.rowNumber.asc()).fetch();
      for (Tuple tuple : invoiceTuples) {
        Invoice invoice = tuple.get(0, Invoice.class);
        InvoiceRow invoiceRow = tuple.get(1, InvoiceRow.class);
        mappedResult.putIfAbsent(invoice.getId(), initializeInvoice(invoice));
        if (invoiceRow != null) {
          mappedResult.get(invoice.getId()).getRows().add(invoiceRow);
        }
      }
    }
    return new ArrayList<>(mappedResult.values());
  }

  private Invoice initializeInvoice(Invoice invoice){
    invoice.setRows(new ArrayList<>());
    return invoice;
  }

  /**
   * Find all invoices for an application
   */
  @Transactional(readOnly = true)
  public List<Invoice> findByApplication(int applicationId) {
     List<Integer> invoiceIds = queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.eq(applicationId)).fetch();
     return findInvoices(invoiceIds);
  }

  @Transactional(readOnly = true)
  public List<Invoice> findInvoicedInvoices(List<Integer> applicationIds) {
    List<Integer> invoiceIds = queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.in(applicationIds), invoice.invoiced.isTrue()).fetch();
    return findInvoices(invoiceIds);
  }

  /**
   * Update an invoice.
   *
   * @param invoiceId The database ID of the invoice to update
   * @param updatedInvoice New contents of the invoice. Note that neither id or
   *          applicationId can be changed.
   */
  @Transactional
  public void update(int invoiceId, Invoice updatedInvoice) {
    long changed = queryFactory.update(invoice).populate(updatedInvoice, EXCLUDE_IDS).where(invoice.id.eq(invoiceId))
        .execute();
    if (changed == 0) {
      throw new NoSuchEntityException("invoice.update.failed", Integer.toString(invoiceId));
    }
    deleteRows(Collections.singletonList(invoiceId));
    insertRows(invoiceId, updatedInvoice.getRows());
  }

  /**
   * Delete invoice.
   *
   * @param invoiceId Invoice's database ID
   */
  @Transactional
  public void deleteSingleInvoice(int invoiceId) {
    deleteRows(Collections.singletonList(invoiceId));
    long changed = queryFactory.delete(invoice).where(invoice.id.eq(invoiceId)).execute();
    if (changed == 0) {
      throw new NoSuchEntityException("invoice.delete.failed", Integer.toString(invoiceId));
    }
  }

  @Transactional
  public void deleteInvoices(List<Integer> invoiceIds, int applicationId) {
    if (EmptyUtil.isNotEmpty(invoiceIds)) {
      deleteRows(invoiceIds);
      long changed = queryFactory.delete(invoice).where(invoice.id.in(invoiceIds)).execute();
      if (changed != invoiceIds.size()) {
        throw new NoSuchEntityException("invoice.delete.failed", "ApplicationId :" + applicationId);
      }
    }
  }

  /**
   * Delete all invoices for given application
   *
   * @param applicationId id that will be used to delete invoices
   */
  @Transactional
  public void deleteOpenInvoicesByApplication(int applicationId) {
    List <Integer> invoiceIds = queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.eq(applicationId), invoice.locked.isFalse(), invoice.invoiced.isFalse()).fetch();
    deleteInvoices(invoiceIds, applicationId);
  }

  @Transactional
  public void deleteUninvoicedByApplication(int applicationId) {
    List<Integer> invoiceIds = queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isFalse()).fetch();
    deleteInvoices(invoiceIds, applicationId);
  }

  /**
   * Retrieve the list of invoices waiting to be sent
   *
   * @return list of invoices
   */
  @Transactional(readOnly = true)
  public List<Invoice> findPending() {
    QApplication application = QApplication.application;
    List<Integer> invoiceIds = queryFactory.select(invoice.id).from(invoice)
        .join(application).on(application.id.eq(invoice.applicationId))
        .where(invoice.invoicableTime.isNotNull(), invoice.invoicableTime.before(ZonedDateTime.now())
            .and(invoice.invoiced.ne(true))
            .and(invoice.sapIdPending.isFalse())
            .and(application.status.notIn(StatusType.CANCELLED, StatusType.REPLACED)))
        .fetch();
     List<Invoice> invoices = findInvoices(invoiceIds);
     return filterIndirectReplacement(invoices);
  }

  private List<Invoice> filterIndirectReplacement(List<Invoice> invoices) {
    List<Integer> applicationIds = invoices.stream().map(Invoice::getApplicationId).collect(Collectors.toList());
    // Checks whether theres application which replaces application with given application id and which is not cancelled
    List<Integer> previousCancels = queryFactory.select(application.replacesApplicationId).from(application)
            .where(application.replacesApplicationId.in(applicationIds).and(application.status.ne(StatusType.CANCELLED)))
            .fetch();
    return invoices.stream().filter(i -> !previousCancels.contains(i.getApplicationId())).collect(Collectors.toList());
  }

  /**
   * Mark given invoices as sent
   *
   * @param invoiceIds the database IDs of the invoices
   */
  @Transactional
  public void markSent(List<Integer> invoiceIds) {
    queryFactory.update(invoice)
      .set(invoice.invoiced, true)
      .set(invoice.sentTime, ZonedDateTime.now())
      .where(invoice.id.in(invoiceIds))
      .execute();
  }

  /**
   * Release pending invoice with given invoice id
   *
   */
  @Transactional
  public void releasePendingInvoice(Integer invoiceId) {
    queryFactory.update(invoice).set(invoice.sapIdPending, Boolean.FALSE).where(invoice.id.eq(invoiceId)).execute();
  }

  @Transactional
  public void setInvoicableTime(int applicationId, ZonedDateTime invoicableTime) {
    queryFactory.update(invoice).set(invoice.invoicableTime, invoicableTime)
        .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isFalse()).execute();
  }

  @Transactional
  public void setInvoicableTimeForPeriod(int periodId, ZonedDateTime invoicableTime) {
    queryFactory.update(invoice).set(invoice.invoicableTime, invoicableTime)
        .where(invoice.invoicingPeriodId.eq(periodId), invoice.invoiced.isFalse()).execute();
  }

  private void deleteRows(List<Integer> invoiceIds) {
    queryFactory.delete(invoiceRow).where(invoiceRow.invoiceId.in(invoiceIds)).execute();
  }

  private void insertRows(int invoiceId, List<InvoiceRow> rows) {
    if (EmptyUtil.isNotEmpty(rows)) {
      SQLInsertClause inserter = queryFactory.insert(invoiceRow);
      for (int rowNum = 0; rowNum < rows.size(); ++rowNum) {
        inserter.populate(rows.get(rowNum))
          .set(invoiceRow.invoiceId, invoiceId).set(invoiceRow.rowNumber, rowNum).addBatch();
      }
      inserter.execute();
    }
  }

  public List<Integer> getApplicationIdsForInvoices(List<Integer> invoiceIds) {
    return queryFactory
        .select(invoice.applicationId)
        .from(invoice)
        .where(invoice.id.in(invoiceIds)).fetch();
  }

  public boolean hasInvoices(int applicationId) {
    return queryFactory.select(invoice.id).from(invoice).where(invoice.applicationId.eq(applicationId))
        .fetchCount() > 0;
  }

  @Transactional
  public void lockInvoices(int applicationId) {
    setInvoicingLocked(applicationId, true);
  }

  private void setInvoicingLocked(int applicationId, boolean isLocked) {
    queryFactory.update(invoice).set(invoice.locked, isLocked).where(invoice.applicationId.eq(applicationId)).execute();
  }

  @Transactional
  public void lockInvoicesOfPeriod(int periodId) {
    queryFactory.update(invoice).set(invoice.locked, true).where(invoice.invoicingPeriodId.eq(periodId)).execute();
  }

  public List<Integer> getChargeBasisIdsInLockedInvoice(int applicationId) {
      return queryFactory
          .select(invoiceRow.chargeBasisId)
          .from(invoiceRow)
          .join(invoice).on(invoice.id.eq(invoiceRow.invoiceId))
          .where(invoice.applicationId.eq(applicationId), invoice.locked.isTrue())
          .fetch();
  }

  @Transactional(readOnly = true)
  public List<Integer> getInvoicedChargeBasisIds(int applicationId) {
    return queryFactory
        .select(invoiceRow.chargeBasisId)
        .from(invoiceRow)
        .join(invoice).on(invoice.id.eq(invoiceRow.invoiceId))
        .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isTrue())
        .fetch();
  }

  @Transactional(readOnly = true)
  public Map<Integer, List<Integer>> getUnvoicedInvoices(List<Integer> applicationIds) {
    Map<Integer, List<Integer>> result = new HashMap<>();
    if (EmptyUtil.isNotEmpty(applicationIds)) {
      result = queryFactory.select(invoice.applicationId, invoice.id).from(invoice)
              .where(invoice.applicationId.in(applicationIds), invoice.invoiced.isFalse())
              .transform(groupBy(invoice.applicationId).as(list(invoice.id)));
    }
      return result;
  }

  @Transactional(readOnly = true)
  public List<Integer> getInvoicePeriodIds(List<Integer> invoiceIds) {
    return queryFactory.select(invoice.invoicingPeriodId).from(invoice)
        .where(invoice.id.in(invoiceIds), invoice.invoicingPeriodId.isNotNull()).fetch();
  }

  @Transactional
  public void setInvoiceRecipient(int applicationId, int invoiceRecipientId, boolean sapIdPending) {
    queryFactory.update(invoice)
      .set(invoice.recipientId, invoiceRecipientId)
      .set(invoice.sapIdPending, sapIdPending)
      .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isFalse())
      .execute();
  }

  @Transactional(readOnly = true)
  public List<InvoiceRow> getInvoiceRows(Integer applicationId) {
    return queryFactory.select(invoiceRowBean)
        .from(invoiceRow)
        .join(invoice).on(invoice.id.eq(invoiceRow.invoiceId))
        .where(invoice.applicationId.eq(applicationId))
        .fetch();
  }

  public void updateInvoiceRow(List<InvoiceRow> existingRows, Map<Integer, InvoiceRow> updatedRowsByChargeBasisId) {
    if (EmptyUtil.isNotEmpty(existingRows) && EmptyUtil.isNotEmpty(updatedRowsByChargeBasisId)) {
      SQLUpdateClause updateClause = queryFactory.update(invoiceRow);
      for (InvoiceRow existingRow : existingRows) {
        Integer chargeId = existingRow.getChargeBasisId();
        if(updatedRowsByChargeBasisId.containsKey(chargeId)){
          updateClause.populate(updatedRowsByChargeBasisId.get(chargeId), EXCLUDE_ROW_IDS).
                  where(invoiceRow.id.eq(existingRow.getId())).addBatch();
        }
      }
    }
  }
}