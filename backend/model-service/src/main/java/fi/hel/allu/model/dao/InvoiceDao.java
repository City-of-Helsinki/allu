package fi.hel.allu.model.dao;

import com.querydsl.core.types.QBean;
import com.querydsl.sql.SQLQueryFactory;
import com.querydsl.sql.dml.SQLInsertClause;

import fi.hel.allu.common.exception.NoSuchEntityException;
import fi.hel.allu.model.domain.Invoice;
import fi.hel.allu.model.domain.InvoiceRow;
import fi.hel.allu.model.querydsl.ExcludingMapper;
import fi.hel.allu.model.querydsl.ExcludingMapper.NullHandling;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static com.querydsl.core.types.Projections.bean;
import static fi.hel.allu.QInvoice.invoice;
import static fi.hel.allu.QInvoiceRow.invoiceRow;

/**
 * The DAO class for invoice access
 */
@Repository
public class InvoiceDao {
  @Autowired
  private SQLQueryFactory queryFactory;

  // While inserting, don't copy id or applicationId from the object:
  private final static ExcludingMapper EXCLUDE_IDS = new ExcludingMapper(NullHandling.DEFAULT,
      Arrays.asList(invoice.id, invoice.applicationId));

  private final QBean<Invoice> invoiceBean = bean(Invoice.class, invoice.all());
  private final QBean<InvoiceRow> invoiceRowBean = bean(InvoiceRow.class, invoiceRow.all());

  /**
   * Insert a new invoice for application. All data except id and applicationId
   * will be copied from the new invoice into database (id will be generated by
   * database and applicationId is set from the parameter applicationId.
   *
   * @param applicationId The application's ID
   * @param newInvoice Contents of the new invoice
   * @return the database id of inserted invoice
   */
  @Transactional
  public int insert(int applicationId, Invoice newInvoice) {
    int invoiceId = queryFactory.insert(invoice)
        .populate(newInvoice, EXCLUDE_IDS)
        .set(invoice.applicationId, applicationId)
        .executeWithKey(invoice.id);
    insertRows(invoiceId, newInvoice.getRows());
    return invoiceId;
  }

  /**
   * Find an invoice by its database ID
   *
   * @param invoiceId The database ID of the invoice
   * @return The found {@link Invoice} or empty {@link Optional}
   */
  @Transactional(readOnly = true)
  public Optional<Invoice> find(int invoiceId) {
    Invoice theInvoice = queryFactory.select(invoiceBean).from(invoice).where(invoice.id.eq(invoiceId)).fetchOne();
    if (theInvoice == null) {
      return Optional.empty();
    } else {
      List<InvoiceRow> rows = queryFactory.select(invoiceRowBean).from(invoiceRow)
          .where(invoiceRow.invoiceId.eq(invoiceId)).orderBy(invoiceRow.rowNumber.asc()).fetch();
      theInvoice.setRows(rows);
      return Optional.of(theInvoice);
    }
  }

  /**
   * Update an invoice.
   *
   * @param invoiceId The database ID of the invoice to update
   * @param updatedInvoice New contents of the invoice. Note that neither id or
   *          applicationId can be changed.
   */
  @Transactional
  public void update(int invoiceId, Invoice updatedInvoice) {
    long changed = queryFactory.update(invoice).populate(updatedInvoice, EXCLUDE_IDS).where(invoice.id.eq(invoiceId))
        .execute();
    if (changed == 0) {
      throw new NoSuchEntityException("Failed to update the record", Integer.toString(invoiceId));
    }
    deleteRows(invoiceId);
    insertRows(invoiceId, updatedInvoice.getRows());
  }

  /**
   * Delete invoice.
   *
   * @param invoiceId Invoice's database ID
   */
  @Transactional
  public void delete(int invoiceId) {
    deleteRows(invoiceId);
    long changed = queryFactory.delete(invoice).where(invoice.id.eq(invoiceId)).execute();
    if (changed == 0) {
      throw new NoSuchEntityException("Deleting invoice failed", Integer.toString(invoiceId));
    }
  }

  private void deleteRows(int invoiceId) {
    queryFactory.delete(invoiceRow).where(invoiceRow.invoiceId.eq(invoiceId)).execute();
  }

  private void insertRows(int invoiceId, List<InvoiceRow> rows) {
    if (rows != null && !rows.isEmpty()) {
      SQLInsertClause inserter = queryFactory.insert(invoiceRow);
      for (int rowNum = 0; rowNum < rows.size(); ++rowNum) {
        inserter.populate(rows.get(rowNum))
          .set(invoiceRow.invoiceId, invoiceId).set(invoiceRow.rowNumber, rowNum).addBatch();
      }
      inserter.execute();
    }
  }
}
