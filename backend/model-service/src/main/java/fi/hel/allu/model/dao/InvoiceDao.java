package fi.hel.allu.model.dao;

import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import fi.hel.allu.common.util.EmptyUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import com.querydsl.core.types.QBean;
import com.querydsl.sql.SQLQueryFactory;
import com.querydsl.sql.dml.SQLInsertClause;

import fi.hel.allu.QApplication;
import fi.hel.allu.common.domain.types.StatusType;
import fi.hel.allu.common.exception.NoSuchEntityException;
import fi.hel.allu.model.domain.Invoice;
import fi.hel.allu.model.domain.InvoiceRow;
import fi.hel.allu.model.querydsl.ExcludingMapper;
import fi.hel.allu.model.querydsl.ExcludingMapper.NullHandling;

import static com.querydsl.core.types.Projections.bean;
import static fi.hel.allu.QApplication.application;
import static fi.hel.allu.QInvoice.invoice;
import static fi.hel.allu.QInvoiceRow.invoiceRow;

/**
 * The DAO class for invoice access
 */
@Repository
public class InvoiceDao {
  @Autowired
  private SQLQueryFactory queryFactory;

  // While inserting, don't copy id or applicationId from the object:
  private final static ExcludingMapper EXCLUDE_IDS = new ExcludingMapper(NullHandling.DEFAULT,
      Arrays.asList(invoice.id, invoice.applicationId));

  private final static ExcludingMapper EXCLUDE_ROW_IDS = new ExcludingMapper(NullHandling.DEFAULT,
      Arrays.asList(invoiceRow.id, invoiceRow.invoiceId));
  private final QBean<Invoice> invoiceBean = bean(Invoice.class, invoice.all());
  private final QBean<InvoiceRow> invoiceRowBean = bean(InvoiceRow.class, invoiceRow.all());

  /**
   * Insert a new invoice for application. All data except id and applicationId
   * will be copied from the new invoice into database (id will be generated by
   * database and applicationId is set from the parameter applicationId.
   *
   * @param applicationId The application's ID
   * @param newInvoice Contents of the new invoice
   * @return the database id of inserted invoice
   */
  @Transactional
  public int insert(int applicationId, Invoice newInvoice) {
    int invoiceId = queryFactory.insert(invoice)
        .populate(newInvoice, EXCLUDE_IDS)
        .set(invoice.applicationId, applicationId)
        .executeWithKey(invoice.id);
    insertRows(invoiceId, newInvoice.getRows());
    return invoiceId;
  }

  /**
   * Find an invoice by its database ID
   *
   * @param invoiceId The database ID of the invoice
   * @return The found {@link Invoice} or empty {@link Optional}
   */
  @Transactional(readOnly = true)
  public Optional<Invoice> find(int invoiceId) {
    Invoice theInvoice = queryFactory.select(invoiceBean).from(invoice).where(invoice.id.eq(invoiceId)).fetchOne();
    if (theInvoice == null) {
      return Optional.empty();
    } else {
      List<InvoiceRow> rows = queryFactory.select(invoiceRowBean).from(invoiceRow)
          .where(invoiceRow.invoiceId.eq(invoiceId)).orderBy(invoiceRow.rowNumber.asc()).fetch();
      theInvoice.setRows(rows);
      return Optional.of(theInvoice);
    }
  }

  /**
   * Find all invoices for an application
   */
  @Transactional(readOnly = true)
  public List<Invoice> findByApplication(int applicationId) {
    return queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.eq(applicationId)).fetch()
        .stream()
        .map(id -> find(id))
        .filter(Optional::isPresent)
        .map(Optional::get)
        .collect(Collectors.toList());
  }

  @Transactional(readOnly = true)
  public List<Invoice> findInvoicedInvoices(List<Integer> applicationIds) {
    return queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.in(applicationIds), invoice.invoiced.isTrue()).fetch()
        .stream()
        .map(id -> find(id))
        .filter(Optional::isPresent)
        .map(Optional::get)
        .collect(Collectors.toList());
  }

  /**
   * Update an invoice.
   *
   * @param invoiceId The database ID of the invoice to update
   * @param updatedInvoice New contents of the invoice. Note that neither id or
   *          applicationId can be changed.
   */
  @Transactional
  public void update(int invoiceId, Invoice updatedInvoice) {
    long changed = queryFactory.update(invoice).populate(updatedInvoice, EXCLUDE_IDS).where(invoice.id.eq(invoiceId))
        .execute();
    if (changed == 0) {
      throw new NoSuchEntityException("invoice.update.failed", Integer.toString(invoiceId));
    }
    deleteRows(invoiceId);
    insertRows(invoiceId, updatedInvoice.getRows());
  }

  /**
   * Delete invoice.
   *
   * @param invoiceId Invoice's database ID
   */
  @Transactional
  public void delete(int invoiceId) {
    deleteRows(invoiceId);
    long changed = queryFactory.delete(invoice).where(invoice.id.eq(invoiceId)).execute();
    if (changed == 0) {
      throw new NoSuchEntityException("invoice.delete.failed", Integer.toString(invoiceId));
    }
  }

  /**
   * Delete all invoices for given application
   *
   * @param applicationId
   */
  @Transactional
  public void deleteOpenInvoicesByApplication(int applicationId) {
    queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.eq(applicationId), invoice.locked.isFalse(), invoice.invoiced.isFalse()).fetch()
        .forEach(id -> delete(id));
  }

  @Transactional
  public void deleteUninvoicedByApplication(int applicationId) {
    queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isFalse()).fetch()
        .forEach(id -> delete(id));
  }

  /**
   * Retrieve the list of invoices waiting to be sent
   *
   * @return list of invoices
   */
  @Transactional(readOnly = true)
  public List<Invoice> findPending() {
    QApplication application =  QApplication.application;
    return queryFactory.select(invoice.id).from(invoice)
        .join(application).on(application.id.eq(invoice.applicationId))
        .where(invoice.invoicableTime.isNotNull(), invoice.invoicableTime.before(ZonedDateTime.now())
            .and(invoice.invoiced.ne(true))
            .and(invoice.sapIdPending.isFalse())
            .and(application.status.notIn(StatusType.CANCELLED, StatusType.REPLACED)))
        .fetch().stream()
        .map(id -> find(id)).filter(Optional::isPresent).map(Optional::get)
          .filter(i -> isNotReplaced(i.getApplicationId()))
          .collect(Collectors.toList());
  }

  private boolean isNotReplaced(Integer applicationId) {
    // Checks whether theres application which replaces application with given application id and which is not cancelled
    return queryFactory.select(application.id).from(application)
        .where(application.replacesApplicationId.eq(applicationId).and(application.status.ne(StatusType.CANCELLED)))
        .fetchCount() == 0;
  }

  /**
   * Mark given invoices as sent
   *
   * @param invoiceIds the database IDs of the invoices
   */
  @Transactional
  public void markSent(List<Integer> invoiceIds) {
    queryFactory.update(invoice)
      .set(invoice.invoiced, true)
      .set(invoice.sentTime, ZonedDateTime.now())
      .where(invoice.id.in(invoiceIds))
      .execute();
  }

  /**
   * Release pending invoice with given invoice id
   *
   */
  @Transactional
  public void releasePendingInvoice(Integer invoiceId) {
    queryFactory.update(invoice).set(invoice.sapIdPending, Boolean.FALSE).where(invoice.id.eq(invoiceId)).execute();
  }

  @Transactional
  public void setInvoicableTime(int applicationId, ZonedDateTime invoicableTime) {
    queryFactory.update(invoice).set(invoice.invoicableTime, invoicableTime)
        .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isFalse()).execute();
  }

  @Transactional
  public void setInvoicableTimeForPeriod(int periodId, ZonedDateTime invoicableTime) {
    queryFactory.update(invoice).set(invoice.invoicableTime, invoicableTime)
        .where(invoice.invoicingPeriodId.eq(periodId), invoice.invoiced.isFalse()).execute();
  }

  private void deleteRows(int invoiceId) {
    queryFactory.delete(invoiceRow).where(invoiceRow.invoiceId.eq(invoiceId)).execute();
  }

  private void insertRows(int invoiceId, List<InvoiceRow> rows) {
    if (EmptyUtil.isNotEmpty(rows)) {
      SQLInsertClause inserter = queryFactory.insert(invoiceRow);
      for (int rowNum = 0; rowNum < rows.size(); ++rowNum) {
        inserter.populate(rows.get(rowNum))
          .set(invoiceRow.invoiceId, invoiceId).set(invoiceRow.rowNumber, rowNum).addBatch();
      }
      inserter.execute();
    }
  }

  public List<Integer> getApplicationIdsForInvoices(List<Integer> invoiceIds) {
    return queryFactory
        .select(invoice.applicationId)
        .from(invoice)
        .where(invoice.id.in(invoiceIds)).fetch();
  }

  public boolean hasInvoices(int applicationId) {
    return queryFactory.select(invoice.id).from(invoice).where(invoice.applicationId.eq(applicationId))
        .fetchCount() > 0;
  }

  @Transactional
  public void lockInvoices(int applicationId) {
    setInvoicingLocked(applicationId, true);
  }

  @Transactional
  public void unlockInvoices(int applicationId) {
    setInvoicingLocked(applicationId, false);
  }

  private void setInvoicingLocked(int applicationId, boolean isLocked) {
    queryFactory.update(invoice).set(invoice.locked, isLocked).where(invoice.applicationId.eq(applicationId)).execute();
  }

  @Transactional
  public void lockInvoicesOfPeriod(int periodId) {
    queryFactory.update(invoice).set(invoice.locked, true).where(invoice.invoicingPeriodId.eq(periodId)).execute();
  }

  public List<Integer> getChargeBasisIdsInLockedInvoice(int applicationId) {
      return queryFactory
          .select(invoiceRow.chargeBasisId)
          .from(invoiceRow)
          .join(invoice).on(invoice.id.eq(invoiceRow.invoiceId))
          .where(invoice.applicationId.eq(applicationId), invoice.locked.isTrue())
          .fetch();
  }

  @Transactional(readOnly = true)
  public List<Integer> getInvoicedChargeBasisIds(int applicationId) {
    return queryFactory
        .select(invoiceRow.chargeBasisId)
        .from(invoiceRow)
        .join(invoice).on(invoice.id.eq(invoiceRow.invoiceId))
        .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isTrue())
        .fetch();
  }

  @Transactional(readOnly = true)
  public boolean hasUninvoicedInvoices(Integer applicationId) {
    return queryFactory.select(invoice.id).from(invoice)
        .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isFalse())
        .fetchCount() > 0;
  }

  @Transactional(readOnly = true)
  public List<Integer> getInvoicePeriodIds(List<Integer> invoiceIds) {
    return queryFactory.select(invoice.invoicingPeriodId).from(invoice)
        .where(invoice.id.in(invoiceIds), invoice.invoicingPeriodId.isNotNull()).fetch();
  }

  @Transactional
  public void setInvoiceRecipient(int applicationId, int invoiceRecipientId, boolean sapIdPending) {
    queryFactory.update(invoice)
      .set(invoice.recipientId, invoiceRecipientId)
      .set(invoice.sapIdPending, sapIdPending)
      .where(invoice.applicationId.eq(applicationId), invoice.invoiced.isFalse())
      .execute();
  }

  @Transactional(readOnly = true)
  public List<InvoiceRow> getInvoiceRows(Integer applicationId) {
    return queryFactory.select(invoiceRowBean)
        .from(invoiceRow)
        .join(invoice).on(invoice.id.eq(invoiceRow.invoiceId))
        .where(invoice.applicationId.eq(applicationId))
        .fetch();
  }

  public void updateInvoiceRow(Integer invoiceRowId, InvoiceRow updatedRow) {
    queryFactory.update(invoiceRow).populate(updatedRow, EXCLUDE_ROW_IDS).where(invoiceRow.id.eq(invoiceRowId))
        .execute();
  }
}